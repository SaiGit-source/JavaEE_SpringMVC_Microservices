RestAPIs:
Before Rest we had SOAP-based web services. it was invented by Roy Fielding


4 projects:

1. Banking rewards: group project - Whenever we purchase with credit card, it gives Rewards. Person should be able to redeem the points, show products on the page, there should be points for the purchase, whenever user register, we can give 1000 points, whenever user does a transaction, we give points like 10 points for 100Rs transaction. do random simulation of transactions every 5 seconds with random amount.

2. Ecommerce: individual project
4 weeks:
1 week-MVP -> we need to write code
2 week-product -> need to code

3. Tours and Travel:
They will give requirements later

4. Realtime quiz - group project
similar to Menti. we got to learn WebSocket


Two services are talking to each other like Udemy and Paypal. when one application is talking to another application it is called as Distributed Enterprise App

Technologies for RestAPIs or to develop Distributed Enterprise Application: CORBA, RMI (one application can seek help of another application), Java came up with Enterprise Java Bean (EJB). the problem with EJB was it was difficult to maintain. with EJB, we cannot connect to another application with a non-Java tech stack. Say Paypal must be in Java as well for EJB to work.

WSI: Web Services Interoperability -> we should come up with business services over web by achieving interoperability. they came up with BP.1.0 -> Basic Profile. in this case, a Java application can talk to a Python Django application. to exchange data between application, thats where web services/Restful services come in picture. Java came up with JAX_RPC to exchange data. web services interoperability help to exchange information between different applications.

After BP.1.0 success BP.1.1. was released. Java team came up with JAX_WS based on specifications from WSI. Apache Axis, IBM WebSphere, Oracle WebLogic, they all provided their own implementations. JAX is Java API for XML. These web services is called as SOAP based web services. for a Java developer it is based on JAX_RPC or JAX_WS. XML is the data exchange format between different applications. Application 1 in Python -> XML object -> Application 2 in Java. For Java developers, in SOAP based services, we use two terminologies Marshelling (Java to XML object) and Unmarshelling (XML to Java object). one application seeking help (consumer application) of another application (provider or producer application).  We document APIs using WSDL -> XML document with producer API information. Consumer -> WSDL -> UDDI -> Producer API. Web Services Description Language -> WSDL (documentation of APIs). UDDI -> Universal Description Discovery Integration. This is the architecture of SOAP based web services

JSON:
due to SOAP-based web services disadvantages, Roy Fielding came up with JavaScript Object Notation (JSON). lets replace XML with JSON. Fielding introduced RESTful services. The address should be unique. Uniform Constant Interface. Based on REST specification, Java came up with JAX_RS. Client -> HTTPRequest -> Rest resource. REST resource sends back HTTPResponse. data exchange format can be in both XML and JSON. SpringMVC has something internally called as SpringREST. SpringMVC uses JacksonAPI to convert JSON object to Java object and vice-versa. Dispatcher servlet(JacksonAPI) will convert say Java Student object into JSON object and vice-versa. void disp(Student st) and returns st Student object only. JacksonAPI will take care of the remaining things. if you add @ResponseBody to a controller method, it becomes a RestAPI. Browser doesn't send JSON data thats why we need Postman tool to test APIs

@Controller + @ResponseBody = @RestController
@RequestBody converts JSON format into Java object -> we use to receive JSON data
for editing data: PUT or PATCH method

What's Global Exception Handling?
For Update, we have @PutMapping, @PatchMapping -> to update majority portion of record, PutMapping otherwise go with PatchMapping

Primary logic -> Application logic, Exception handling is secondary logic (AOP)

Purpose of Controller method is receive HttpRequest process then give it back -> @RestControllerAdvice (exception is handled automatically). @ExceptionHandler -> no try and catch.

Main purpose of AOP is to separate main logic and secondary logic -> Aspect Oriented Programming

Globally i would like to handle exceptions of the application. When i send request to RestAPI, it calls the service method to process the request. if exception occurs, instead of exception going to RestController it goes into RestControllerAdvice. that's Aspect Oriented Programming (AOP)

How to integrate third party application like Paypal into our application? RestTemplate (Synchronous) or WebClient (Asynchronous communication)

Scopes, Swagger: Passenger details -> Web app -> Book a ticket (Two Applications interacting with APIs)
				   <- 	      <-(response)

we are developing APIs for use by some other developers so we dont share code source, thats why we use @Operation(). how to connect from one appln to another appln via APIs? thats why we need RestTemplate and WebClient

Reactive programming: For WebClient add Spring Reactive Web dependency in Spring application. Method chaining webClient.post().uri(url).body(passenger).retrieve().bodyToMono(Integer.class).block(); // block for synchronous request. post request to URL send body, retrieve convert response to Integer class.

WebClient
block() means webclient will act as Synchronous that means thread will wait. But if you use Subscribe it is Asynchronous communication that means thread will not wait

RestTemplate is only for Synchronous communication

When to go with RestTemplate vs WebClient

if you want to make a call to third-party APIs like PayPal, Razor, WhatsApp, we got to use either RestTemplate or WebClient
	
WeatherApp -> City -> ZipCode API   	WeatherApp -> ZipCode -> WeatherAPI 
	<- ZipCode				    <-- Weather info

if ZipCode API doesn't generate ZipCode we cannot run WeatherAPI so one thread must wait if we dont have response from ZipCodeAPI. without response from ZipCode API we cannot call Weather Info API -> Synchronous communication (by default RestTemplate supports that, WebClient with block. that means dont proceed further unless we have a response from API1, when you use WebClient with subscribe() method then it becomes asynchronous communication)  

Sometimes we want Emp Personal Info and Emp payslip both APIs are independent of each other so communication can happen in parallel. So Asynchronous communication will work here. WebClient with subscribe() method will do



































